import assert, { deepEqual } from "node:assert";
import fs from "node:fs";
import { describe, it } from "node:test";
import * as x509 from "@peculiar/x509";
import { Bytes, BytesBlob } from "@typeberry/bytes";
import { ed25519 } from "@typeberry/crypto";
import { ed25519AsJsonWebKeyPair, generateCertificate, verifyCertificate } from "./certificate";

const ALICE_CERT = fs.readFileSync("./fixtures/alice-imported.cert.pem", "utf8").trim();
const BOB_CERT = fs.readFileSync("./fixtures/bob-generated.cert.pem", "utf8").trim();

describe("X509 Certificate", () => {
  it("should generate cert", async () => {
    const ed25519Pair = await ed25519.privateKey(Bytes.fill(ed25519.ED25519_PRIV_KEY_BYTES, 1).asOpaque());
    const keyPair = ed25519AsJsonWebKeyPair(ed25519Pair);

    const cert = await generateCertificate({
      certId: BytesBlob.blobFromString("QUIC Networking"),
      subjectKeyPair: keyPair,
      issuerKeyPair: keyPair,
      now: new Date("2025-05-03 11:00:00"),
    });

    const altName = cert.getExtension(x509.SubjectAlternativeNameExtension);

    // make sure the alternative name is correct
    assert.strictEqual(
      altName?.toString(),
      "Subject Alternative Name:\n" + "  DNS: erkeohxlubhyzl7ks3mwtzos5olfgocn7dwkbeg7toseadnapn5oa",
    );

    // check the whole certificate
    assert.deepStrictEqual(cert.toString(), BOB_CERT);
  });

  it("should validate certificate generated by openssl", async () => {
    const cert = new x509.X509Certificate(ALICE_CERT);
    const certDer = new Uint8Array(cert.rawData);

    // when
    const verificationResult = await verifyCertificate([certDer]);

    // then
    deepEqual(verificationResult, {
      // TODO [ToDr] id, key
    });
  });
});
